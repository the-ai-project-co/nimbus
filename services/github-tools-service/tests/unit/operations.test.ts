import { describe, test, expect, beforeEach, afterEach, mock } from 'bun:test';
import { GitHubOperations } from '../../src/github/operations';

describe('GitHubOperations', () => {
  let githubOps: GitHubOperations;
  let octokit: any;

  /**
   * Store original octokit method references so we can restore them in afterEach.
   * Bun's spyOn cannot intercept Octokit endpoint methods (they are dynamically
   * generated by Octokit's plugin system), so we use direct assignment with mock().
   */
  let originals: Map<string, Function>;

  /** Helper to save the original and assign a mock to an octokit namespace method */
  function mockOctokit(namespace: string, method: string, impl: (...args: any[]) => any) {
    const key = `${namespace}.${method}`;
    if (!originals.has(key)) {
      originals.set(key, octokit[namespace][method]);
    }
    const fn = mock(impl);
    octokit[namespace][method] = fn;
    return fn;
  }

  beforeEach(() => {
    originals = new Map();
    githubOps = new GitHubOperations('test-token');
    octokit = (githubOps as any).octokit;

    // Set up default mock implementations for all octokit methods used in tests.
    // Individual tests override with mockResolvedValueOnce as needed.
    mockOctokit('pulls', 'list', async () => ({ data: [] }));
    mockOctokit('pulls', 'get', async () => ({ data: { number: 1, title: 'PR Title' } }));
    mockOctokit('pulls', 'create', async () => ({ data: { number: 1, title: 'New PR' } }));
    mockOctokit('pulls', 'merge', async () => ({
      data: { sha: 'abc123', merged: true, message: 'Merged' },
    }));
    mockOctokit('pulls', 'update', async () => ({ data: { number: 1, state: 'closed' } }));

    mockOctokit('issues', 'listForRepo', async () => ({ data: [] }));
    mockOctokit('issues', 'get', async () => ({ data: { number: 1, title: 'Issue Title' } }));
    mockOctokit('issues', 'create', async () => ({ data: { number: 1, title: 'New Issue' } }));
    mockOctokit('issues', 'update', async () => ({ data: { number: 1, state: 'closed' } }));
    mockOctokit('issues', 'createComment', async () => ({ data: { id: 1, body: 'Comment' } }));
    mockOctokit('issues', 'listComments', async () => ({ data: [] }));

    mockOctokit('repos', 'get', async () => ({
      data: { name: 'repo', full_name: 'owner/repo' },
    }));
    mockOctokit('repos', 'listBranches', async () => ({ data: [] }));
    mockOctokit('repos', 'getBranch', async () => ({
      data: { name: 'main', commit: { sha: 'abc123' } },
    }));

    mockOctokit('git', 'createRef', async () => ({
      data: { ref: 'refs/heads/new-branch', object: { sha: 'abc123' } },
    }));
    mockOctokit('git', 'deleteRef', async () => ({}));

    mockOctokit('users', 'getAuthenticated', async () => ({
      data: { login: 'user', name: 'User', email: 'user@test.com' },
    }));
  });

  afterEach(() => {
    // Restore original octokit methods so mocks do not leak to other test files
    for (const [key, original] of originals) {
      const [namespace, method] = key.split('.');
      octokit[namespace][method] = original;
    }
    originals.clear();
  });

  describe('Pull Request Operations', () => {
    describe('listPRs', () => {
      test('should list pull requests', async () => {
        octokit.pulls.list.mockResolvedValueOnce({
          data: [
            { number: 1, title: 'PR 1' },
            { number: 2, title: 'PR 2' },
          ],
        });

        const prs = await githubOps.listPRs('owner', 'repo');

        expect(Array.isArray(prs)).toBe(true);
        expect(octokit.pulls.list).toHaveBeenCalled();
      });

      test('should list PRs with state filter', async () => {
        octokit.pulls.list.mockResolvedValueOnce({ data: [] });

        await githubOps.listPRs('owner', 'repo', 'closed');

        expect(octokit.pulls.list).toHaveBeenCalledWith(
          expect.objectContaining({ state: 'closed' })
        );
      });
    });

    describe('getPR', () => {
      test('should get a pull request', async () => {
        octokit.pulls.get.mockResolvedValueOnce({
          data: { number: 1, title: 'Test PR', state: 'open' },
        });

        const pr = await githubOps.getPR('owner', 'repo', 1);

        expect(pr.number).toBe(1);
        expect(pr.title).toBe('Test PR');
      });
    });

    describe('createPR', () => {
      test('should create a pull request', async () => {
        octokit.pulls.create.mockResolvedValueOnce({
          data: { number: 1, title: 'New PR', html_url: 'https://github.com/...' },
        });

        const pr = await githubOps.createPR('owner', 'repo', {
          title: 'New PR',
          head: 'feature',
          base: 'main',
        });

        expect(pr.title).toBe('New PR');
        expect(octokit.pulls.create).toHaveBeenCalled();
      });

      test('should create a draft PR', async () => {
        octokit.pulls.create.mockResolvedValueOnce({
          data: { number: 1, draft: true },
        });

        const pr = await githubOps.createPR('owner', 'repo', {
          title: 'Draft PR',
          head: 'feature',
          base: 'main',
          draft: true,
        });

        expect(octokit.pulls.create).toHaveBeenCalledWith(
          expect.objectContaining({ draft: true })
        );
      });
    });

    describe('mergePR', () => {
      test('should merge a pull request', async () => {
        octokit.pulls.merge.mockResolvedValueOnce({
          data: { sha: 'abc123', merged: true, message: 'Pull Request merged' },
        });

        const result = await githubOps.mergePR('owner', 'repo', 1);

        expect(result.merged).toBe(true);
      });

      test('should merge with squash', async () => {
        octokit.pulls.merge.mockResolvedValueOnce({
          data: { sha: 'abc123', merged: true, message: 'Squash merged' },
        });

        await githubOps.mergePR('owner', 'repo', 1, { merge_method: 'squash' });

        expect(octokit.pulls.merge).toHaveBeenCalledWith(
          expect.objectContaining({ merge_method: 'squash' })
        );
      });
    });

    describe('closePR', () => {
      test('should close a pull request', async () => {
        octokit.pulls.update.mockResolvedValueOnce({
          data: { number: 1, state: 'closed' },
        });

        const pr = await githubOps.closePR('owner', 'repo', 1);

        expect(octokit.pulls.update).toHaveBeenCalledWith(
          expect.objectContaining({ state: 'closed' })
        );
      });
    });
  });

  describe('Issue Operations', () => {
    describe('listIssues', () => {
      test('should list issues', async () => {
        octokit.issues.listForRepo.mockResolvedValueOnce({
          data: [{ number: 1, title: 'Issue 1' }],
        });

        const issues = await githubOps.listIssues('owner', 'repo');

        expect(Array.isArray(issues)).toBe(true);
      });

      test('should filter out pull requests', async () => {
        octokit.issues.listForRepo.mockResolvedValueOnce({
          data: [
            { number: 1, title: 'Issue' },
            { number: 2, title: 'PR', pull_request: {} },
          ],
        });

        const issues = await githubOps.listIssues('owner', 'repo');

        expect(issues.length).toBe(1);
      });
    });

    describe('getIssue', () => {
      test('should get an issue', async () => {
        octokit.issues.get.mockResolvedValueOnce({
          data: { number: 1, title: 'Test Issue' },
        });

        const issue = await githubOps.getIssue('owner', 'repo', 1);

        expect(issue.number).toBe(1);
      });
    });

    describe('createIssue', () => {
      test('should create an issue', async () => {
        octokit.issues.create.mockResolvedValueOnce({
          data: { number: 1, title: 'New Issue' },
        });

        const issue = await githubOps.createIssue('owner', 'repo', {
          title: 'New Issue',
        });

        expect(issue.title).toBe('New Issue');
      });

      test('should create issue with labels', async () => {
        octokit.issues.create.mockResolvedValueOnce({
          data: { number: 1, labels: [{ name: 'bug' }] },
        });

        await githubOps.createIssue('owner', 'repo', {
          title: 'Bug',
          labels: ['bug'],
        });

        expect(octokit.issues.create).toHaveBeenCalledWith(
          expect.objectContaining({ labels: ['bug'] })
        );
      });
    });

    describe('updateIssue', () => {
      test('should update an issue', async () => {
        octokit.issues.update.mockResolvedValueOnce({
          data: { number: 1, title: 'Updated Title' },
        });

        const issue = await githubOps.updateIssue('owner', 'repo', 1, {
          title: 'Updated Title',
        });

        expect(octokit.issues.update).toHaveBeenCalled();
      });
    });

    describe('closeIssue', () => {
      test('should close an issue', async () => {
        octokit.issues.update.mockResolvedValueOnce({
          data: { number: 1, state: 'closed' },
        });

        await githubOps.closeIssue('owner', 'repo', 1);

        expect(octokit.issues.update).toHaveBeenCalledWith(
          expect.objectContaining({ state: 'closed' })
        );
      });
    });

    describe('addComment', () => {
      test('should add a comment', async () => {
        octokit.issues.createComment.mockResolvedValueOnce({
          data: { id: 1, body: 'Test comment' },
        });

        const comment = await githubOps.addComment('owner', 'repo', 1, 'Test comment');

        expect(octokit.issues.createComment).toHaveBeenCalled();
      });
    });

    describe('listComments', () => {
      test('should list comments', async () => {
        octokit.issues.listComments.mockResolvedValueOnce({
          data: [{ id: 1, body: 'Comment 1' }],
        });

        const comments = await githubOps.listComments('owner', 'repo', 1);

        expect(Array.isArray(comments)).toBe(true);
      });
    });
  });

  describe('Repository Operations', () => {
    describe('getRepo', () => {
      test('should get repository info', async () => {
        octokit.repos.get.mockResolvedValueOnce({
          data: { name: 'repo', full_name: 'owner/repo', default_branch: 'main' },
        });

        const repo = await githubOps.getRepo('owner', 'repo');

        expect(repo.name).toBe('repo');
      });
    });

    describe('listBranches', () => {
      test('should list branches', async () => {
        octokit.repos.listBranches.mockResolvedValueOnce({
          data: [{ name: 'main' }, { name: 'develop' }],
        });

        const branches = await githubOps.listBranches('owner', 'repo');

        expect(Array.isArray(branches)).toBe(true);
      });
    });

    describe('getBranch', () => {
      test('should get branch', async () => {
        octokit.repos.getBranch.mockResolvedValueOnce({
          data: { name: 'main', commit: { sha: 'abc123' } },
        });

        const branch = await githubOps.getBranch('owner', 'repo', 'main');

        expect(branch.name).toBe('main');
        expect(branch.commit.sha).toBe('abc123');
      });
    });

    describe('createBranch', () => {
      test('should create a branch', async () => {
        octokit.git.createRef.mockResolvedValueOnce({
          data: { ref: 'refs/heads/new-branch', object: { sha: 'abc123' } },
        });

        const result = await githubOps.createBranch('owner', 'repo', 'new-branch', 'abc123');

        expect(result.ref).toBe('refs/heads/new-branch');
      });
    });

    describe('deleteBranch', () => {
      test('should delete a branch', async () => {
        octokit.git.deleteRef.mockResolvedValueOnce({});

        await githubOps.deleteBranch('owner', 'repo', 'old-branch');

        expect(octokit.git.deleteRef).toHaveBeenCalledWith(
          expect.objectContaining({ ref: 'heads/old-branch' })
        );
      });
    });
  });

  describe('Authentication', () => {
    describe('validateToken', () => {
      test('should validate token and return user info', async () => {
        octokit.users.getAuthenticated.mockResolvedValueOnce({
          data: { login: 'testuser', name: 'Test User', email: 'test@test.com' },
        });

        const user = await githubOps.validateToken();

        expect(user.login).toBe('testuser');
        expect(user.name).toBe('Test User');
      });
    });
  });
});
