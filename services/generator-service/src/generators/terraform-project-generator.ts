/**
 * Terraform Project Generator
 *
 * Generates complete Terraform project structures with environment separation,
 * module scaffolding, and post-generation validation pipeline.
 *
 * Addresses:
 * - Gap #9:  Post-generation validation pipeline
 * - Gap #10: Environment separation (dev/staging/prod tfvars)
 * - Gap #11: Full project structure generation
 * - Gap #12: tflint-style checks
 */

import { logger } from '@nimbus/shared-utils';

// ==========================================
// Types
// ==========================================

/** Configuration for generating a Terraform project. */
export interface TerraformProjectConfig {
  /** Name of the project used for resource naming and tagging. */
  projectName: string;
  /** Cloud provider target. */
  provider: 'aws' | 'gcp' | 'azure';
  /** Cloud provider region. */
  region: string;
  /** Default environment. */
  environment?: string;
  /** Infrastructure components to include (e.g. vpc, eks, rds, s3). */
  components: string[];
  /** Remote state backend configuration. */
  backendConfig?: {
    bucket: string;
    dynamodbTable?: string;
    key?: string;
  };
  /** Common resource tags. */
  tags?: Record<string, string>;
}

/** A single generated file with its relative path and content. */
export interface GeneratedFile {
  path: string;
  content: string;
}

/** A single item from the validation pipeline. */
export interface ValidationItem {
  severity: 'error' | 'warning' | 'info';
  message: string;
  file?: string;
  line?: number;
  rule?: string;
}

/** Aggregated validation report for a generated project. */
export interface ValidationReport {
  valid: boolean;
  items: ValidationItem[];
  summary: {
    errors: number;
    warnings: number;
    info: number;
  };
}

/** The complete output of the project generator. */
export interface GeneratedProject {
  files: GeneratedFile[];
  validation: ValidationReport;
}

// ==========================================
// Generator
// ==========================================

/**
 * Generates a complete Terraform project structure including:
 * - Root configuration files (main.tf, variables.tf, outputs.tf, versions.tf, backend.tf)
 * - Environment-specific tfvars (dev, staging, prod)
 * - Component modules with main, variables, and outputs
 * - Post-generation validation pipeline
 */
export class TerraformProjectGenerator {
  /**
   * Generate a full Terraform project from the given configuration.
   */
  async generate(config: TerraformProjectConfig): Promise<GeneratedProject> {
    logger.info(`Generating Terraform project: ${config.projectName}`);

    const files: GeneratedFile[] = [];

    // 1. Root configuration files
    files.push(this.generateMainTf(config));
    files.push(this.generateVariablesTf(config));
    files.push(this.generateOutputsTf(config));
    files.push(this.generateVersionsTf(config));
    files.push(this.generateBackendTf(config));

    // 2. Example tfvars
    files.push(this.generateTfvarsExample(config));

    // 3. README
    files.push(this.generateReadme(config));

    // 4. Environment-specific tfvars (Gap #10)
    files.push(this.generateEnvTfvars(config, 'dev'));
    files.push(this.generateEnvTfvars(config, 'staging'));
    files.push(this.generateEnvTfvars(config, 'prod'));

    // 5. Module files for each component (Gap #11)
    for (const component of config.components) {
      files.push(...this.generateModuleFiles(config, component));
    }

    // 6. Run validation pipeline (Gap #9 + #12)
    const validation = this.validateProject(files, config);

    return { files, validation };
  }

  // ===== File Generators =====

  private generateMainTf(config: TerraformProjectConfig): GeneratedFile {
    const providerBlock = this.getProviderBlock(config);
    const moduleBlocks = config.components
      .map(c => this.getModuleBlock(config, c))
      .join('\n\n');

    return {
      path: 'main.tf',
      content: `# ${config.projectName} - Main Configuration
# Generated by Nimbus

${providerBlock}

${moduleBlocks}
`,
    };
  }

  private generateVariablesTf(config: TerraformProjectConfig): GeneratedFile {
    const vars: string[] = [
      `# ${config.projectName} - Variables`,
      '# Generated by Nimbus',
      '',
      'variable "project_name" {',
      '  description = "Name of the project"',
      '  type        = string',
      `  default     = "${config.projectName}"`,
      '}',
      '',
      'variable "environment" {',
      '  description = "Environment (dev, staging, prod)"',
      '  type        = string',
      `  default     = "${config.environment || 'dev'}"`,
      '',
      '  validation {',
      '    condition     = contains(["dev", "staging", "prod"], var.environment)',
      '    error_message = "Environment must be dev, staging, or prod."',
      '  }',
      '}',
      '',
      'variable "region" {',
      '  description = "Cloud provider region"',
      '  type        = string',
      `  default     = "${config.region}"`,
      '}',
      '',
      'variable "tags" {',
      '  description = "Common tags for all resources"',
      '  type        = map(string)',
      '  default = {',
      `    Project     = "${config.projectName}"`,
      '    ManagedBy   = "terraform"',
      '    Environment = "dev"',
      '  }',
      '}',
    ];

    // Add component-specific variables
    if (config.components.includes('vpc')) {
      vars.push(
        '',
        'variable "vpc_cidr" {',
        '  description = "VPC CIDR block"',
        '  type        = string',
        '  default     = "10.0.0.0/16"',
        '}',
      );
      vars.push(
        '',
        'variable "availability_zones" {',
        '  description = "List of availability zones"',
        '  type        = list(string)',
        `  default     = ["${config.region}a", "${config.region}b"]`,
        '}',
      );
    }

    if (config.components.includes('eks')) {
      vars.push(
        '',
        'variable "cluster_version" {',
        '  description = "EKS cluster version"',
        '  type        = string',
        '  default     = "1.28"',
        '}',
      );
      vars.push(
        '',
        'variable "node_instance_type" {',
        '  description = "EKS node instance type"',
        '  type        = string',
        '  default     = "t3.medium"',
        '}',
      );
      vars.push(
        '',
        'variable "node_count" {',
        '  description = "Number of EKS worker nodes"',
        '  type        = number',
        '  default     = 2',
        '}',
      );
    }

    if (config.components.includes('rds')) {
      vars.push(
        '',
        'variable "db_instance_class" {',
        '  description = "RDS instance class"',
        '  type        = string',
        '  default     = "db.t3.micro"',
        '}',
      );
      vars.push(
        '',
        'variable "db_engine" {',
        '  description = "Database engine"',
        '  type        = string',
        '  default     = "postgres"',
        '}',
      );
      vars.push(
        '',
        'variable "db_storage_size" {',
        '  description = "Database storage size in GB"',
        '  type        = number',
        '  default     = 20',
        '}',
      );
    }

    if (config.components.includes('s3')) {
      vars.push(
        '',
        'variable "bucket_name" {',
        '  description = "S3 bucket name"',
        '  type        = string',
        `  default     = "${config.projectName}-storage"`,
        '}',
      );
    }

    return { path: 'variables.tf', content: vars.join('\n') + '\n' };
  }

  private generateOutputsTf(config: TerraformProjectConfig): GeneratedFile {
    const outputs: string[] = [
      `# ${config.projectName} - Outputs`,
      '# Generated by Nimbus',
      '',
    ];

    if (config.components.includes('vpc')) {
      outputs.push(
        'output "vpc_id" {',
        '  description = "VPC ID"',
        '  value       = module.vpc.vpc_id',
        '}',
        '',
      );
    }

    if (config.components.includes('eks')) {
      outputs.push(
        'output "eks_cluster_endpoint" {',
        '  description = "EKS cluster endpoint"',
        '  value       = module.eks.cluster_endpoint',
        '}',
        '',
      );
      outputs.push(
        'output "eks_cluster_name" {',
        '  description = "EKS cluster name"',
        '  value       = module.eks.cluster_name',
        '}',
        '',
      );
    }

    if (config.components.includes('rds')) {
      outputs.push(
        'output "rds_endpoint" {',
        '  description = "RDS endpoint"',
        '  value       = module.rds.endpoint',
        '  sensitive   = true',
        '}',
        '',
      );
    }

    if (config.components.includes('s3')) {
      outputs.push(
        'output "s3_bucket_arn" {',
        '  description = "S3 bucket ARN"',
        '  value       = module.s3.bucket_arn',
        '}',
        '',
      );
    }

    return { path: 'outputs.tf', content: outputs.join('\n') };
  }

  private generateVersionsTf(config: TerraformProjectConfig): GeneratedFile {
    const providerSource =
      config.provider === 'aws'
        ? 'hashicorp/aws'
        : config.provider === 'gcp'
          ? 'hashicorp/google'
          : 'hashicorp/azurerm';

    const providerVersion =
      config.provider === 'aws'
        ? '~> 5.0'
        : config.provider === 'gcp'
          ? '~> 5.0'
          : '~> 3.0';

    const providerName =
      config.provider === 'gcp' ? 'google' : config.provider;

    return {
      path: 'versions.tf',
      content: `# Terraform and Provider Versions
# Generated by Nimbus

terraform {
  required_version = ">= 1.5.0"

  required_providers {
    ${providerName} = {
      source  = "${providerSource}"
      version = "${providerVersion}"
    }
  }
}
`,
    };
  }

  private generateBackendTf(config: TerraformProjectConfig): GeneratedFile {
    const bucket =
      config.backendConfig?.bucket || `${config.projectName}-tfstate`;
    const key =
      config.backendConfig?.key || `${config.projectName}/terraform.tfstate`;
    const dynamodbTable =
      config.backendConfig?.dynamodbTable || `${config.projectName}-tflock`;

    if (config.provider === 'aws') {
      return {
        path: 'backend.tf',
        content: `# Remote State Configuration
# Generated by Nimbus

terraform {
  backend "s3" {
    bucket         = "${bucket}"
    key            = "${key}"
    region         = "${config.region}"
    dynamodb_table = "${dynamodbTable}"
    encrypt        = true
  }
}
`,
      };
    }

    // GCP/Azure backends
    return {
      path: 'backend.tf',
      content: `# Remote State Configuration
# Generated by Nimbus
# Configure your backend before running terraform init

# terraform {
#   backend "${config.provider === 'gcp' ? 'gcs' : 'azurerm'}" {
#     # Configure your backend settings
#   }
# }
`,
    };
  }

  private generateTfvarsExample(config: TerraformProjectConfig): GeneratedFile {
    const lines = [
      `# ${config.projectName} - Example Variables`,
      '# Copy this file and customize for your environment',
      '# Generated by Nimbus',
      '',
      `project_name = "${config.projectName}"`,
      'environment  = "dev"',
      `region       = "${config.region}"`,
      '',
    ];

    if (config.components.includes('vpc')) {
      lines.push('vpc_cidr = "10.0.0.0/16"');
    }
    if (config.components.includes('eks')) {
      lines.push('node_instance_type = "t3.medium"');
      lines.push('node_count         = 2');
    }
    if (config.components.includes('rds')) {
      lines.push('db_instance_class = "db.t3.micro"');
    }

    return { path: 'terraform.tfvars.example', content: lines.join('\n') + '\n' };
  }

  private generateReadme(config: TerraformProjectConfig): GeneratedFile {
    return {
      path: 'README.md',
      content: `# ${config.projectName}

Infrastructure as Code managed by Terraform. Generated by Nimbus.

## Components
${config.components.map(c => `- ${c.toUpperCase()}`).join('\n')}

## Environments
- \`dev\` - Development environment
- \`staging\` - Staging environment
- \`prod\` - Production environment

## Usage

\`\`\`bash
# Initialize
terraform init

# Plan with environment-specific vars
terraform plan -var-file="environments/dev/terraform.tfvars"

# Apply
terraform apply -var-file="environments/dev/terraform.tfvars"
\`\`\`

## Structure
\`\`\`
.
├── main.tf                          # Main configuration
├── variables.tf                     # Variable definitions
├── outputs.tf                       # Output definitions
├── versions.tf                      # Terraform and provider versions
├── backend.tf                       # Remote state configuration
├── terraform.tfvars.example         # Example variable values
├── environments/
│   ├── dev/terraform.tfvars         # Dev environment values
│   ├── staging/terraform.tfvars     # Staging environment values
│   └── prod/terraform.tfvars        # Production environment values
└── modules/                         # Component modules
${config.components.map(c => `    └── ${c}/`).join('\n')}
\`\`\`
`,
    };
  }

  private generateEnvTfvars(
    config: TerraformProjectConfig,
    env: 'dev' | 'staging' | 'prod',
  ): GeneratedFile {
    const envConfigs = {
      dev: {
        instanceType: 't3.small',
        nodeCount: 1,
        dbClass: 'db.t3.micro',
        dbStorage: 20,
        azCount: 2,
        cidr: '10.0.0.0/16',
      },
      staging: {
        instanceType: 't3.medium',
        nodeCount: 2,
        dbClass: 'db.t3.small',
        dbStorage: 50,
        azCount: 2,
        cidr: '10.1.0.0/16',
      },
      prod: {
        instanceType: 't3.large',
        nodeCount: 3,
        dbClass: 'db.r6g.large',
        dbStorage: 100,
        azCount: 3,
        cidr: '10.2.0.0/16',
      },
    };

    const c = envConfigs[env];
    const azs = Array.from(
      { length: c.azCount },
      (_, i) => `"${config.region}${String.fromCharCode(97 + i)}"`,
    );

    const lines = [
      `# ${config.projectName} - ${env.charAt(0).toUpperCase() + env.slice(1)} Environment`,
      '# Generated by Nimbus',
      '',
      `project_name = "${config.projectName}"`,
      `environment  = "${env}"`,
      `region       = "${config.region}"`,
      '',
      'tags = {',
      `  Project     = "${config.projectName}"`,
      `  Environment = "${env}"`,
      '  ManagedBy   = "terraform"',
      '}',
      '',
    ];

    if (config.components.includes('vpc')) {
      lines.push(`vpc_cidr           = "${c.cidr}"`);
      lines.push(`availability_zones = [${azs.join(', ')}]`);
      lines.push('');
    }

    if (config.components.includes('eks')) {
      lines.push(`node_instance_type = "${c.instanceType}"`);
      lines.push(`node_count         = ${c.nodeCount}`);
      lines.push('');
    }

    if (config.components.includes('rds')) {
      lines.push(`db_instance_class = "${c.dbClass}"`);
      lines.push(`db_storage_size   = ${c.dbStorage}`);
      lines.push('');
    }

    return {
      path: `environments/${env}/terraform.tfvars`,
      content: lines.join('\n'),
    };
  }

  private generateModuleFiles(
    config: TerraformProjectConfig,
    component: string,
  ): GeneratedFile[] {
    const files: GeneratedFile[] = [];

    files.push({
      path: `modules/${component}/main.tf`,
      content: this.getModuleMainTf(config, component),
    });

    files.push({
      path: `modules/${component}/variables.tf`,
      content: this.getModuleVariablesTf(component),
    });

    files.push({
      path: `modules/${component}/outputs.tf`,
      content: this.getModuleOutputsTf(component),
    });

    return files;
  }

  // ===== Validation Pipeline (Gap #9 + #12) =====

  /**
   * Validate a set of generated Terraform files.
   * Runs structural, syntactic, and best-practice checks similar to tflint.
   */
  validateProject(
    files: GeneratedFile[],
    _config?: TerraformProjectConfig,
  ): ValidationReport {
    const items: ValidationItem[] = [];

    // 1. Check required files are present
    items.push(...this.checkRequiredFiles(files));

    // 2. Basic HCL syntax validation
    items.push(...this.checkHclSyntax(files));

    // 3. Check for anti-patterns (tflint-style)
    items.push(...this.checkAntiPatterns(files));

    // 4. Check for missing tags on resources
    items.push(...this.checkMissingTags(files));

    const errors = items.filter(i => i.severity === 'error').length;
    const warnings = items.filter(i => i.severity === 'warning').length;
    const info = items.filter(i => i.severity === 'info').length;

    return {
      valid: errors === 0,
      items,
      summary: { errors, warnings, info },
    };
  }

  private checkRequiredFiles(files: GeneratedFile[]): ValidationItem[] {
    const items: ValidationItem[] = [];
    const requiredFiles = [
      'main.tf',
      'variables.tf',
      'outputs.tf',
      'versions.tf',
      'backend.tf',
    ];
    const filePaths = files.map(f => f.path);

    for (const required of requiredFiles) {
      if (!filePaths.includes(required)) {
        items.push({
          severity: 'error',
          message: `Required file missing: ${required}`,
          rule: 'required-files',
        });
      }
    }

    // Check environment files
    for (const env of ['dev', 'staging', 'prod']) {
      if (!filePaths.includes(`environments/${env}/terraform.tfvars`)) {
        items.push({
          severity: 'warning',
          message: `Missing environment tfvars: environments/${env}/terraform.tfvars`,
          rule: 'env-separation',
        });
      }
    }

    return items;
  }

  private checkHclSyntax(files: GeneratedFile[]): ValidationItem[] {
    const items: ValidationItem[] = [];

    for (const file of files) {
      if (!file.path.endsWith('.tf')) continue;

      // Check matching braces
      const openBraces = (file.content.match(/\{/g) || []).length;
      const closeBraces = (file.content.match(/\}/g) || []).length;
      if (openBraces !== closeBraces) {
        items.push({
          severity: 'error',
          message: `Mismatched braces: ${openBraces} open, ${closeBraces} close`,
          file: file.path,
          rule: 'hcl-syntax',
        });
      }

      // Check matching quotes
      const quoteCount = (file.content.match(/"/g) || []).length;
      if (quoteCount % 2 !== 0) {
        items.push({
          severity: 'error',
          message: 'Unmatched quotes detected',
          file: file.path,
          rule: 'hcl-syntax',
        });
      }

      // Check for valid resource/module/variable declarations
      const lines = file.content.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (
          line.startsWith('resource ') ||
          line.startsWith('module ') ||
          line.startsWith('variable ')
        ) {
          if (!line.includes('{') && !line.includes('"')) {
            items.push({
              severity: 'warning',
              message: `Potentially malformed declaration: ${line.substring(0, 60)}`,
              file: file.path,
              line: i + 1,
              rule: 'hcl-syntax',
            });
          }
        }
      }
    }

    return items;
  }

  private checkAntiPatterns(files: GeneratedFile[]): ValidationItem[] {
    const items: ValidationItem[] = [];

    for (const file of files) {
      if (!file.path.endsWith('.tf')) continue;

      const lines = file.content.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check for hardcoded AWS account IDs (12-digit numbers)
        if (/\d{12}/.test(line) && !line.trim().startsWith('#')) {
          items.push({
            severity: 'warning',
            message: 'Possible hardcoded AWS account ID',
            file: file.path,
            line: i + 1,
            rule: 'no-hardcoded-values',
          });
        }

        // Check for hardcoded secrets/passwords
        if (
          /password\s*=\s*"[^"]*[^v][^a][^r]/.test(line.toLowerCase()) &&
          !line.trim().startsWith('#')
        ) {
          items.push({
            severity: 'error',
            message: 'Possible hardcoded password',
            file: file.path,
            line: i + 1,
            rule: 'no-hardcoded-secrets',
          });
        }

        // Check for publicly accessible resources
        if (/publicly_accessible\s*=\s*true/.test(line) && !line.trim().startsWith('#')) {
          items.push({
            severity: 'warning',
            message: 'Resource is publicly accessible',
            file: file.path,
            line: i + 1,
            rule: 'no-public-access',
          });
        }
      }
    }

    return items;
  }

  private checkMissingTags(files: GeneratedFile[]): ValidationItem[] {
    const items: ValidationItem[] = [];

    for (const file of files) {
      if (
        !file.path.endsWith('.tf') ||
        file.path.includes('variables') ||
        file.path.includes('outputs') ||
        file.path.includes('versions')
      )
        continue;

      // Check if resource blocks have tags
      const hasResources = /resource\s+"/.test(file.content);
      const hasTags =
        /tags\s*=/.test(file.content) || /tags\s*\{/.test(file.content);

      if (hasResources && !hasTags) {
        items.push({
          severity: 'warning',
          message: 'Resource blocks without tags attribute',
          file: file.path,
          rule: 'require-tags',
        });
      }
    }

    return items;
  }

  // ===== Helper Methods =====

  private getProviderBlock(config: TerraformProjectConfig): string {
    if (config.provider === 'aws') {
      return `provider "aws" {
  region = var.region

  default_tags {
    tags = var.tags
  }
}`;
    }

    if (config.provider === 'gcp') {
      return `provider "google" {
  region  = var.region
  project = var.project_name
}`;
    }

    return `provider "azurerm" {
  features {}
}`;
  }

  private getModuleBlock(
    config: TerraformProjectConfig,
    component: string,
  ): string {
    const commonVars = `  project_name = var.project_name
  environment  = var.environment
  tags         = var.tags`;

    switch (component) {
      case 'vpc':
        return `module "vpc" {
  source = "./modules/vpc"

${commonVars}
  vpc_cidr           = var.vpc_cidr
  availability_zones = var.availability_zones
}`;

      case 'eks':
        return `module "eks" {
  source = "./modules/eks"

${commonVars}
  vpc_id             = module.vpc.vpc_id
  subnet_ids         = module.vpc.private_subnet_ids
  cluster_version    = var.cluster_version
  node_instance_type = var.node_instance_type
  node_count         = var.node_count

  depends_on = [module.vpc]
}`;

      case 'rds':
        return `module "rds" {
  source = "./modules/rds"

${commonVars}
  vpc_id          = module.vpc.vpc_id
  subnet_ids      = module.vpc.private_subnet_ids
  instance_class  = var.db_instance_class
  engine          = var.db_engine
  storage_size    = var.db_storage_size

  depends_on = [module.vpc]
}`;

      case 's3':
        return `module "s3" {
  source = "./modules/s3"

${commonVars}
  bucket_name = var.bucket_name
}`;

      default:
        return `module "${component}" {
  source = "./modules/${component}"

${commonVars}
}`;
    }
  }

  private getModuleMainTf(
    _config: TerraformProjectConfig,
    component: string,
  ): string {
    switch (component) {
      case 'vpc':
        return `# VPC Module
# Generated by Nimbus

resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = merge(var.tags, {
    Name = "\${var.project_name}-\${var.environment}-vpc"
  })
}

resource "aws_subnet" "private" {
  count             = length(var.availability_zones)
  vpc_id            = aws_vpc.main.id
  cidr_block        = cidrsubnet(var.vpc_cidr, 8, count.index)
  availability_zone = var.availability_zones[count.index]

  tags = merge(var.tags, {
    Name = "\${var.project_name}-\${var.environment}-private-\${count.index}"
    Type = "private"
  })
}

resource "aws_subnet" "public" {
  count                   = length(var.availability_zones)
  vpc_id                  = aws_vpc.main.id
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index + length(var.availability_zones))
  availability_zone       = var.availability_zones[count.index]
  map_public_ip_on_launch = true

  tags = merge(var.tags, {
    Name = "\${var.project_name}-\${var.environment}-public-\${count.index}"
    Type = "public"
  })
}
`;

      case 'eks':
        return `# EKS Module
# Generated by Nimbus

resource "aws_eks_cluster" "main" {
  name     = "\${var.project_name}-\${var.environment}"
  role_arn = aws_iam_role.cluster.arn
  version  = var.cluster_version

  vpc_config {
    subnet_ids              = var.subnet_ids
    endpoint_private_access = true
    endpoint_public_access  = false
  }

  encryption_config {
    resources = ["secrets"]
    provider {
      key_arn = aws_kms_key.eks.arn
    }
  }

  tags = var.tags
}
`;

      case 'rds':
        return `# RDS Module
# Generated by Nimbus

resource "aws_db_instance" "main" {
  identifier     = "\${var.project_name}-\${var.environment}"
  instance_class = var.instance_class
  engine         = var.engine
  allocated_storage = var.storage_size

  storage_encrypted       = true
  backup_retention_period = 7
  publicly_accessible     = false
  multi_az               = var.environment == "prod" ? true : false

  db_subnet_group_name = aws_db_subnet_group.main.name

  tags = var.tags
}

resource "aws_db_subnet_group" "main" {
  name       = "\${var.project_name}-\${var.environment}"
  subnet_ids = var.subnet_ids

  tags = var.tags
}
`;

      case 's3':
        return `# S3 Module
# Generated by Nimbus

resource "aws_s3_bucket" "main" {
  bucket = "\${var.bucket_name}-\${var.environment}"

  tags = var.tags
}

resource "aws_s3_bucket_versioning" "main" {
  bucket = aws_s3_bucket.main.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_server_side_encryption_configuration" "main" {
  bucket = aws_s3_bucket.main.id
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "aws:kms"
    }
  }
}

resource "aws_s3_bucket_public_access_block" "main" {
  bucket = aws_s3_bucket.main.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}
`;

      default:
        return `# ${component} Module\n# Generated by Nimbus\n`;
    }
  }

  private getModuleVariablesTf(component: string): string {
    const common = `variable "project_name" {
  type = string
}

variable "environment" {
  type = string
}

variable "tags" {
  type    = map(string)
  default = {}
}
`;

    switch (component) {
      case 'vpc':
        return `${common}
variable "vpc_cidr" {
  type    = string
  default = "10.0.0.0/16"
}

variable "availability_zones" {
  type = list(string)
}
`;

      case 'eks':
        return `${common}
variable "vpc_id" {
  type = string
}

variable "subnet_ids" {
  type = list(string)
}

variable "cluster_version" {
  type    = string
  default = "1.28"
}

variable "node_instance_type" {
  type    = string
  default = "t3.medium"
}

variable "node_count" {
  type    = number
  default = 2
}
`;

      case 'rds':
        return `${common}
variable "vpc_id" {
  type = string
}

variable "subnet_ids" {
  type = list(string)
}

variable "instance_class" {
  type    = string
  default = "db.t3.micro"
}

variable "engine" {
  type    = string
  default = "postgres"
}

variable "storage_size" {
  type    = number
  default = 20
}
`;

      case 's3':
        return `${common}
variable "bucket_name" {
  type = string
}
`;

      default:
        return common;
    }
  }

  private getModuleOutputsTf(component: string): string {
    switch (component) {
      case 'vpc':
        return `output "vpc_id" {
  value = aws_vpc.main.id
}

output "private_subnet_ids" {
  value = aws_subnet.private[*].id
}

output "public_subnet_ids" {
  value = aws_subnet.public[*].id
}
`;

      case 'eks':
        return `output "cluster_endpoint" {
  value = aws_eks_cluster.main.endpoint
}

output "cluster_name" {
  value = aws_eks_cluster.main.name
}
`;

      case 'rds':
        return `output "endpoint" {
  value     = aws_db_instance.main.endpoint
  sensitive = true
}
`;

      case 's3':
        return `output "bucket_arn" {
  value = aws_s3_bucket.main.arn
}

output "bucket_name" {
  value = aws_s3_bucket.main.id
}
`;

      default:
        return '';
    }
  }
}
