/**
 * Init Command
 *
 * Initialize a Nimbus workspace in the current directory
 * Performs comprehensive project scanning to detect:
 * - Languages and versions
 * - Frameworks
 * - Package managers
 * - Infrastructure as Code (Terraform, Pulumi, CDK, etc.)
 * - CI/CD platforms
 * - Cloud providers
 */

import * as fs from 'fs';
import * as path from 'path';
import { ui } from '../wizard/ui';
import { select, input, confirm } from '../wizard/prompts';
import {
  createProjectScanner,
  generateProjectYaml,
  type ProjectContext,
  type ScanOptions,
} from '../scanners';
import { initContextDatabase } from '../context/context-db';

export interface InitOptions {
  /** Non-interactive mode */
  nonInteractive?: boolean;
  /** Force overwrite existing configuration */
  force?: boolean;
  /** Project name */
  name?: string;
  /** Default cloud provider */
  provider?: string;
  /** Output directory */
  output?: string;
  /** Scan depth: quick, standard, or deep */
  scanDepth?: 'quick' | 'standard' | 'deep';
  /** Custom project instructions */
  instructions?: string;
  /** Template to use: vpc, eks, full-stack, minimal */
  template?: 'vpc' | 'eks' | 'full-stack' | 'minimal';
  /** Import from existing IaC directory */
  fromExisting?: string;
  /** Maximum directory depth for project scanning */
  maxDepth?: number;
}

const NIMBUS_DIR = '.nimbus';
const PROJECT_FILE = 'project.yaml';
const CONFIG_FILE = 'config.yaml';

// Template definitions
const TEMPLATES: Record<string, { description: string; files: Record<string, string> }> = {
  vpc: {
    description: 'AWS VPC with subnets, NAT gateway, and security groups',
    files: {
      'terraform/main.tf': `# VPC Infrastructure
# Generated by Nimbus

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  name = var.project_name
  cidr = var.vpc_cidr

  azs             = var.availability_zones
  private_subnets = var.private_subnet_cidrs
  public_subnets  = var.public_subnet_cidrs

  enable_nat_gateway     = true
  single_nat_gateway     = var.single_nat_gateway
  enable_dns_hostnames   = true
  enable_dns_support     = true

  tags = var.tags
}
`,
      'terraform/variables.tf': `variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "vpc_cidr" {
  description = "CIDR block for VPC"
  type        = string
  default     = "10.0.0.0/16"
}

variable "availability_zones" {
  description = "Availability zones"
  type        = list(string)
  default     = ["us-east-1a", "us-east-1b", "us-east-1c"]
}

variable "private_subnet_cidrs" {
  description = "CIDR blocks for private subnets"
  type        = list(string)
  default     = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
}

variable "public_subnet_cidrs" {
  description = "CIDR blocks for public subnets"
  type        = list(string)
  default     = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]
}

variable "single_nat_gateway" {
  description = "Use single NAT gateway for cost savings"
  type        = bool
  default     = true
}

variable "tags" {
  description = "Tags to apply to resources"
  type        = map(string)
  default     = {}
}
`,
      'terraform/outputs.tf': `output "vpc_id" {
  description = "VPC ID"
  value       = module.vpc.vpc_id
}

output "private_subnet_ids" {
  description = "Private subnet IDs"
  value       = module.vpc.private_subnets
}

output "public_subnet_ids" {
  description = "Public subnet IDs"
  value       = module.vpc.public_subnets
}

output "nat_gateway_ips" {
  description = "NAT Gateway IPs"
  value       = module.vpc.nat_public_ips
}
`,
      'terraform/terraform.tfvars.example': `project_name = "my-project"
aws_region   = "us-east-1"
vpc_cidr     = "10.0.0.0/16"

tags = {
  Environment = "dev"
  ManagedBy   = "terraform"
}
`,
    },
  },
  eks: {
    description: 'AWS EKS cluster with VPC and node groups',
    files: {
      'terraform/main.tf': `# EKS Infrastructure
# Generated by Nimbus

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  name = "\${var.project_name}-vpc"
  cidr = var.vpc_cidr

  azs             = var.availability_zones
  private_subnets = var.private_subnet_cidrs
  public_subnets  = var.public_subnet_cidrs

  enable_nat_gateway   = true
  single_nat_gateway   = true
  enable_dns_hostnames = true

  public_subnet_tags = {
    "kubernetes.io/role/elb" = 1
  }

  private_subnet_tags = {
    "kubernetes.io/role/internal-elb" = 1
  }

  tags = var.tags
}

module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 19.0"

  cluster_name    = var.project_name
  cluster_version = var.cluster_version

  vpc_id     = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnets

  cluster_endpoint_public_access = true

  eks_managed_node_groups = {
    default = {
      min_size     = var.node_min_size
      max_size     = var.node_max_size
      desired_size = var.node_desired_size

      instance_types = var.node_instance_types
      capacity_type  = "ON_DEMAND"
    }
  }

  tags = var.tags
}
`,
      'terraform/variables.tf': `variable "project_name" {
  description = "Name of the project / EKS cluster"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "cluster_version" {
  description = "Kubernetes version"
  type        = string
  default     = "1.28"
}

variable "vpc_cidr" {
  description = "CIDR block for VPC"
  type        = string
  default     = "10.0.0.0/16"
}

variable "availability_zones" {
  description = "Availability zones"
  type        = list(string)
  default     = ["us-east-1a", "us-east-1b"]
}

variable "private_subnet_cidrs" {
  description = "CIDR blocks for private subnets"
  type        = list(string)
  default     = ["10.0.1.0/24", "10.0.2.0/24"]
}

variable "public_subnet_cidrs" {
  description = "CIDR blocks for public subnets"
  type        = list(string)
  default     = ["10.0.101.0/24", "10.0.102.0/24"]
}

variable "node_instance_types" {
  description = "Instance types for node group"
  type        = list(string)
  default     = ["t3.medium"]
}

variable "node_min_size" {
  description = "Minimum number of nodes"
  type        = number
  default     = 1
}

variable "node_max_size" {
  description = "Maximum number of nodes"
  type        = number
  default     = 5
}

variable "node_desired_size" {
  description = "Desired number of nodes"
  type        = number
  default     = 2
}

variable "tags" {
  description = "Tags to apply to resources"
  type        = map(string)
  default     = {}
}
`,
      'terraform/outputs.tf': `output "cluster_endpoint" {
  description = "EKS cluster endpoint"
  value       = module.eks.cluster_endpoint
}

output "cluster_name" {
  description = "EKS cluster name"
  value       = module.eks.cluster_name
}

output "cluster_certificate_authority_data" {
  description = "Base64 encoded certificate data"
  value       = module.eks.cluster_certificate_authority_data
  sensitive   = true
}

output "configure_kubectl" {
  description = "Configure kubectl"
  value       = "aws eks update-kubeconfig --region \${var.aws_region} --name \${module.eks.cluster_name}"
}
`,
    },
  },
  'full-stack': {
    description: 'Complete AWS stack with VPC, EKS, RDS, and ElastiCache',
    files: {
      'terraform/main.tf': `# Full Stack Infrastructure
# Generated by Nimbus

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  name = "\${var.project_name}-vpc"
  cidr = "10.0.0.0/16"

  azs              = ["us-east-1a", "us-east-1b"]
  private_subnets  = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets   = ["10.0.101.0/24", "10.0.102.0/24"]
  database_subnets = ["10.0.201.0/24", "10.0.202.0/24"]

  enable_nat_gateway   = true
  single_nat_gateway   = true
  enable_dns_hostnames = true

  create_database_subnet_group = true

  tags = var.tags
}

# EKS Cluster
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 19.0"

  cluster_name    = "\${var.project_name}-cluster"
  cluster_version = "1.28"

  vpc_id     = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnets

  cluster_endpoint_public_access = true

  eks_managed_node_groups = {
    default = {
      min_size       = 2
      max_size       = 10
      desired_size   = 3
      instance_types = ["t3.medium"]
    }
  }

  tags = var.tags
}

# RDS PostgreSQL
module "rds" {
  source  = "terraform-aws-modules/rds/aws"
  version = "~> 6.0"

  identifier = "\${var.project_name}-db"

  engine               = "postgres"
  engine_version       = "15"
  family               = "postgres15"
  major_engine_version = "15"
  instance_class       = "db.t3.micro"

  allocated_storage     = 20
  max_allocated_storage = 100

  db_name  = "app"
  username = "dbadmin"
  port     = 5432

  db_subnet_group_name   = module.vpc.database_subnet_group_name
  vpc_security_group_ids = [aws_security_group.rds.id]

  maintenance_window      = "Mon:00:00-Mon:03:00"
  backup_window           = "03:00-06:00"
  backup_retention_period = 7

  tags = var.tags
}

# ElastiCache Redis
resource "aws_elasticache_subnet_group" "main" {
  name       = "\${var.project_name}-cache-subnet"
  subnet_ids = module.vpc.private_subnets
}

resource "aws_elasticache_cluster" "main" {
  cluster_id           = "\${var.project_name}-cache"
  engine               = "redis"
  node_type            = "cache.t3.micro"
  num_cache_nodes      = 1
  parameter_group_name = "default.redis7"
  port                 = 6379
  subnet_group_name    = aws_elasticache_subnet_group.main.name
  security_group_ids   = [aws_security_group.redis.id]

  tags = var.tags
}

# Security Groups
resource "aws_security_group" "rds" {
  name        = "\${var.project_name}-rds-sg"
  description = "Allow PostgreSQL from VPC"
  vpc_id      = module.vpc.vpc_id

  ingress {
    from_port   = 5432
    to_port     = 5432
    protocol    = "tcp"
    cidr_blocks = [module.vpc.vpc_cidr_block]
  }

  tags = var.tags
}

resource "aws_security_group" "redis" {
  name        = "\${var.project_name}-redis-sg"
  description = "Allow Redis from VPC"
  vpc_id      = module.vpc.vpc_id

  ingress {
    from_port   = 6379
    to_port     = 6379
    protocol    = "tcp"
    cidr_blocks = [module.vpc.vpc_cidr_block]
  }

  tags = var.tags
}
`,
      'terraform/variables.tf': `variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "tags" {
  description = "Tags to apply to resources"
  type        = map(string)
  default = {
    ManagedBy = "terraform"
  }
}
`,
      'terraform/outputs.tf': `output "vpc_id" {
  value = module.vpc.vpc_id
}

output "eks_cluster_endpoint" {
  value = module.eks.cluster_endpoint
}

output "rds_endpoint" {
  value = module.rds.db_instance_endpoint
}

output "redis_endpoint" {
  value = aws_elasticache_cluster.main.cache_nodes[0].address
}
`,
    },
  },
  minimal: {
    description: 'Minimal Terraform setup with just provider configuration',
    files: {
      'terraform/main.tf': `# Minimal Terraform Configuration
# Generated by Nimbus

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

  # Uncomment to use S3 backend
  # backend "s3" {
  #   bucket = "your-terraform-state-bucket"
  #   key    = "terraform.tfstate"
  #   region = "us-east-1"
  # }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      ManagedBy = "terraform"
      Project   = var.project_name
    }
  }
}
`,
      'terraform/variables.tf': `variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "environment" {
  description = "Environment (dev, staging, prod)"
  type        = string
  default     = "dev"
}
`,
      'terraform/outputs.tf': `# Add outputs here as you create resources
`,
      'terraform/.gitignore': `# Terraform
*.tfstate
*.tfstate.*
.terraform/
.terraform.lock.hcl
*.tfvars
!*.tfvars.example
crash.log
override.tf
override.tf.json
*_override.tf
*_override.tf.json
`,
    },
  },
};

/**
 * Generate template files
 */
function generateTemplateFiles(templateName: string, outputDir: string, projectName: string): void {
  const template = TEMPLATES[templateName];
  if (!template) {
    return;
  }

  for (const [filePath, content] of Object.entries(template.files)) {
    const fullPath = path.join(outputDir, filePath);
    const dir = path.dirname(fullPath);

    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Replace project name placeholder
    const finalContent = content.replace(/\$\{var\.project_name\}/g, projectName);
    fs.writeFileSync(fullPath, finalContent);
  }
}

/**
 * Create .gitignore entry for Nimbus
 */
function createGitignoreEntry(): string {
  return `
# Nimbus
.nimbus/
*.nimbus-session
`;
}

/**
 * Display scan results in a summary table
 */
function displayScanSummary(context: ProjectContext): void {
  ui.newLine();
  ui.section('Project Analysis');

  // Languages
  if (context.structure.languages.length > 0) {
    ui.print(`  ${ui.bold('Languages:')}`);
    for (const lang of context.structure.languages.slice(0, 5)) {
      const version = lang.version ? ` (${lang.version})` : '';
      const confidence =
        lang.confidence === 'high' ? ui.color('●', 'green') : ui.color('○', 'yellow');
      ui.print(`    ${confidence} ${lang.name}${version}`);
    }
    if (context.structure.languages.length > 5) {
      ui.print(ui.dim(`    ... and ${context.structure.languages.length - 5} more`));
    }
    ui.newLine();
  }

  // Frameworks
  if (context.structure.frameworks.length > 0) {
    ui.print(`  ${ui.bold('Frameworks:')}`);
    for (const fw of context.structure.frameworks.slice(0, 5)) {
      const version = fw.version ? ` (${fw.version})` : '';
      const confidence =
        fw.confidence === 'high' ? ui.color('●', 'green') : ui.color('○', 'yellow');
      ui.print(`    ${confidence} ${fw.name}${version}`);
    }
    if (context.structure.frameworks.length > 5) {
      ui.print(ui.dim(`    ... and ${context.structure.frameworks.length - 5} more`));
    }
    ui.newLine();
  }

  // Package Managers
  if (context.structure.packageManagers.length > 0) {
    ui.print(`  ${ui.bold('Package Managers:')}`);
    const pmList = context.structure.packageManagers.map(pm => pm.name).join(', ');
    ui.print(`    ${pmList}`);
    ui.newLine();
  }

  // Infrastructure
  const hasInfra =
    context.files.terraform.length > 0 ||
    context.files.kubernetes.length > 0 ||
    context.files.docker.length > 0;
  if (hasInfra) {
    ui.print(`  ${ui.bold('Infrastructure:')}`);
    if (context.files.terraform.length > 0) {
      ui.print(`    ${ui.color('●', 'green')} Terraform (${context.files.terraform.length} files)`);
    }
    if (context.files.kubernetes.length > 0) {
      ui.print(
        `    ${ui.color('●', 'green')} Kubernetes (${context.files.kubernetes.length} files)`
      );
    }
    if (context.files.docker.length > 0) {
      ui.print(`    ${ui.color('●', 'green')} Docker (${context.files.docker.length} files)`);
    }
    ui.newLine();
  }

  // CI/CD
  if (context.cicd.platform) {
    ui.print(`  ${ui.bold('CI/CD:')}`);
    ui.print(
      `    ${ui.color('●', 'green')} ${context.cicd.platform} (${context.cicd.workflows.length} workflows)`
    );
    ui.newLine();
  }

  // Cloud Providers
  if (context.cloud.providers.length > 0) {
    ui.print(`  ${ui.bold('Cloud Providers:')}`);
    for (const provider of context.cloud.providers) {
      ui.print(`    ${ui.color('●', 'green')} ${provider.toUpperCase()}`);
    }
    if (context.cloud.regions.length > 0) {
      ui.print(`    ${ui.dim('Regions:')} ${context.cloud.regions.slice(0, 5).join(', ')}`);
    }
    ui.newLine();
  }

  // Git Info
  if (context.git.isRepo) {
    ui.print(`  ${ui.bold('Git:')}`);
    ui.print(`    Branch: ${context.git.branch}`);
    if (context.git.remote) {
      ui.print(`    Remote: ${context.git.remote}`);
    }
    ui.newLine();
  }

  // Project Type
  ui.print(`  ${ui.bold('Project Type:')} ${context.structure.type}`);
  ui.newLine();
}

/**
 * Create workspace config.yaml
 */
function createWorkspaceConfig(options: {
  name: string;
  provider?: string;
  output?: string;
}): string {
  const lines: string[] = [
    '# Nimbus Workspace Configuration',
    '# This file configures Nimbus for this project.',
    '# See project.yaml for detected project context.',
    '',
    'workspace:',
    `  name: ${options.name}`,
  ];

  if (options.provider) {
    lines.push(`  defaultProvider: ${options.provider}`);
  }

  if (options.output) {
    lines.push(`  outputDirectory: ${options.output}`);
  }

  lines.push('');
  lines.push('# Safety settings');
  lines.push('safety:');
  lines.push('  requireApproval: true');
  lines.push('  protectedEnvironments: [production, prod]');
  lines.push('  costThreshold: 500');

  return `${lines.join('\n')}\n`;
}

/**
 * Init command handler
 */
export async function initCommand(options: InitOptions = {}): Promise<void> {
  const cwd = process.cwd();
  const nimbusDir = path.join(cwd, NIMBUS_DIR);
  const projectPath = path.join(nimbusDir, PROJECT_FILE);
  const configPath = path.join(nimbusDir, CONFIG_FILE);

  // Check if already initialized
  if (fs.existsSync(nimbusDir) && !options.force) {
    ui.warning(`Nimbus workspace already exists at: ${nimbusDir}`);

    if (!options.nonInteractive) {
      const reinit = await confirm({
        message: 'Reinitialize this workspace?',
        defaultValue: false,
      });

      if (!reinit) {
        ui.info('Workspace unchanged.');
        return;
      }
    } else {
      ui.info('Use --force to reinitialize.');
      return;
    }
  }

  // Start scanning
  ui.newLine();
  ui.header('Initialize Nimbus Workspace', cwd);

  const scanDepth = options.scanDepth || 'standard';
  ui.startSpinner({ message: `Scanning project (${scanDepth} mode)...` });

  // Create scanner and run scan
  const scanner = createProjectScanner();
  const scanOptions: Partial<ScanOptions> = {
    depth: scanDepth,
    instructions: options.instructions,
    maxDepth: options.maxDepth,
  };

  let context: ProjectContext;
  try {
    context = await scanner.scan(cwd, scanOptions);
    ui.stopSpinnerSuccess('Project scan complete');
  } catch (error) {
    ui.stopSpinnerFail('Project scan failed');
    ui.error((error as Error).message);
    return;
  }

  // Display scan summary
  displayScanSummary(context);

  // Interactive configuration
  let projectName = options.name || context.project.name;
  let provider = options.provider;
  let outputDir = options.output;

  if (!options.nonInteractive) {
    // Project name
    projectName = await input({
      message: 'Project name:',
      defaultValue: context.project.name,
    });

    // Cloud provider - pre-select if detected
    const detectedProvider = context.cloud.providers[0] || '';
    const providerOptions = [
      { label: 'AWS', value: 'aws', description: 'Amazon Web Services' },
      { label: 'GCP', value: 'gcp', description: 'Google Cloud Platform' },
      { label: 'Azure', value: 'azure', description: 'Microsoft Azure' },
      { label: 'None', value: '', description: 'No default provider' },
    ];

    // Move detected provider to top
    if (detectedProvider) {
      const idx = providerOptions.findIndex(o => o.value === detectedProvider);
      if (idx > 0) {
        const [detected] = providerOptions.splice(idx, 1);
        detected.label += ' (detected)';
        providerOptions.unshift(detected);
      }
    }

    provider = (await select({
      message: 'Default cloud provider:',
      options: providerOptions,
    })) as string;

    // Output directory
    const defaultOutput = context.files.terraform.length > 0 ? './terraform' : './infrastructure';
    outputDir = await input({
      message: 'Output directory for generated code:',
      defaultValue: defaultOutput,
    });

    // Update .gitignore
    const gitignorePath = path.join(cwd, '.gitignore');
    if (fs.existsSync(gitignorePath)) {
      const gitignoreContent = fs.readFileSync(gitignorePath, 'utf-8');
      if (!gitignoreContent.includes('.nimbus/')) {
        const updateGitignore = await confirm({
          message: 'Add .nimbus/ to .gitignore?',
          defaultValue: true,
        });

        if (updateGitignore) {
          fs.appendFileSync(gitignorePath, createGitignoreEntry());
          ui.success('Updated .gitignore');
        }
      }
    }
  } else {
    // Non-interactive: use detected or default values
    provider = provider || context.cloud.providers[0] || '';
    outputDir =
      outputDir || (context.files.terraform.length > 0 ? './terraform' : './infrastructure');
  }

  // Update context with user-provided name
  context.project.name = projectName;

  // Create .nimbus directory
  if (!fs.existsSync(nimbusDir)) {
    fs.mkdirSync(nimbusDir, { recursive: true });
  }

  // Generate and write project.yaml
  const projectYaml = generateProjectYaml(context);
  fs.writeFileSync(projectPath, projectYaml);

  // Generate and write config.yaml
  const configContent = createWorkspaceConfig({
    name: projectName,
    provider: provider || undefined,
    output: outputDir || undefined,
  });
  fs.writeFileSync(configPath, configContent);

  // Create .gitkeep for empty directories
  const gitkeepPath = path.join(nimbusDir, '.gitkeep');
  if (!fs.existsSync(gitkeepPath)) {
    fs.writeFileSync(gitkeepPath, '');
  }

  // Initialize context database
  try {
    const contextDb = initContextDatabase(cwd);
    contextDb.recordCommand('init', `--name ${projectName}`, 'success');
    contextDb.close();
  } catch {
    // Non-critical: context DB is optional
  }

  // Generate template files if specified
  if (options.template) {
    const template = TEMPLATES[options.template];
    if (template) {
      ui.startSpinner({ message: `Generating ${options.template} template...` });
      generateTemplateFiles(options.template, cwd, projectName);
      ui.stopSpinnerSuccess(`Generated ${options.template} template`);
    }
  } else if (!options.nonInteractive && context.files.terraform.length === 0) {
    // Offer to generate a template if no existing Terraform
    const useTemplate = await confirm({
      message: 'No existing Terraform files found. Generate a starter template?',
      defaultValue: true,
    });

    if (useTemplate) {
      const templateChoice = await select({
        message: 'Select a template:',
        options: [
          { label: 'Minimal', value: 'minimal', description: 'Basic provider setup' },
          { label: 'VPC', value: 'vpc', description: 'AWS VPC with subnets and NAT' },
          { label: 'EKS', value: 'eks', description: 'EKS cluster with VPC' },
          { label: 'Full Stack', value: 'full-stack', description: 'VPC + EKS + RDS + Redis' },
        ],
      });

      ui.startSpinner({ message: `Generating ${templateChoice} template...` });
      generateTemplateFiles(templateChoice as string, cwd, projectName);
      ui.stopSpinnerSuccess(`Generated ${templateChoice} template`);
    }
  }

  // Prompt for telemetry opt-in
  if (!options.nonInteractive) {
    ui.newLine();
    const enableTelemetry = await confirm({
      message: 'Enable anonymous usage telemetry? (helps improve Nimbus)',
      defaultValue: false,
    });

    if (enableTelemetry) {
      try {
        const { homedir } = await import('os');
        const telemetryConfigPath = path.join(homedir(), '.nimbus', 'config.json');
        const telemetryDir = path.join(homedir(), '.nimbus');

        if (!fs.existsSync(telemetryDir)) {
          fs.mkdirSync(telemetryDir, { recursive: true });
        }

        let telemetryConfig: any = {};
        try {
          if (fs.existsSync(telemetryConfigPath)) {
            telemetryConfig = JSON.parse(fs.readFileSync(telemetryConfigPath, 'utf-8'));
          }
        } catch {
          /* ignore */
        }

        const { randomUUID } = await import('crypto');
        telemetryConfig.telemetry = {
          ...telemetryConfig.telemetry,
          enabled: true,
          anonymousId: telemetryConfig.telemetry?.anonymousId || randomUUID(),
        };
        fs.writeFileSync(telemetryConfigPath, JSON.stringify(telemetryConfig, null, 2));
        ui.success('Telemetry enabled');
      } catch {
        // Non-critical
      }
    }
  }

  ui.newLine();
  ui.success(`Nimbus workspace initialized!`);
  ui.newLine();
  ui.print(`  ${ui.dim('Project:')}  ${projectName}`);
  ui.print(`  ${ui.dim('Type:')}     ${context.structure.type}`);
  ui.print(`  ${ui.dim('Config:')}   ${configPath}`);
  ui.print(`  ${ui.dim('Context:')}  ${projectPath}`);
  if (provider) {
    ui.print(`  ${ui.dim('Provider:')} ${provider}`);
  }
  if (outputDir) {
    ui.print(`  ${ui.dim('Output:')}   ${outputDir}`);
  }
  ui.newLine();

  // Show detected summary
  const summaryItems: string[] = [];
  if (context.structure.languages.length > 0) {
    summaryItems.push(`${context.structure.languages.length} languages`);
  }
  if (context.structure.frameworks.length > 0) {
    summaryItems.push(`${context.structure.frameworks.length} frameworks`);
  }
  if (context.files.terraform.length > 0) {
    summaryItems.push('Terraform');
  }
  if (context.files.kubernetes.length > 0) {
    summaryItems.push('Kubernetes');
  }
  if (context.cicd.platform) {
    summaryItems.push(context.cicd.platform);
  }
  if (summaryItems.length > 0) {
    ui.print(ui.dim(`  Detected: ${summaryItems.join(', ')}`));
    ui.newLine();
  }

  ui.print(ui.dim('Next steps:'));
  ui.print(`  ${ui.dim('1.')} Run ${ui.color('nimbus login', 'cyan')} to configure authentication`);
  ui.print(`  ${ui.dim('2.')} Run ${ui.color('nimbus chat', 'cyan')} to start a conversation`);
  if (context.files.terraform.length > 0) {
    ui.print(
      `  ${ui.dim('3.')} Run ${ui.color('nimbus plan terraform', 'cyan')} to preview infrastructure`
    );
  } else {
    ui.print(
      `  ${ui.dim('3.')} Run ${ui.color('nimbus generate terraform', 'cyan')} to generate infrastructure`
    );
  }
  ui.newLine();
}
